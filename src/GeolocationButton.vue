<template>
  <span :id="`geolocation-wrapper+${id}`" class="geolocation">
    <v-btn 
      v-if="!hideButton"
      class="geolocation-button"
      :density="density"
      :size="size"
      :variant="geolocation ? (useTextButton ? 'tonal' : 'flat') : 'outlined'"
      :elevation="elevation"
      :loading="loading"
      :icon="useTextButton ? undefined : icon"
      :prepend-icon="useTextButton ? icon : undefined"
      :color="geolocationError ? 'red' : color"
      @click="getLocation" 
      :text="useTextButton ? label : undefined"
    />


    <span v-if="showTextProgress && loading">
      <v-progress-circular
        :size="progressCircleSize"
        :width="2"
        :color="color"
        indeterminate
      ></v-progress-circular> 
      Fetching locations
    </span>

    <span class="geolocation-text" v-if="showTextLabel && !useTextButton">
      <v-progress-circular
        v-if="loading && showTextProgress"
        :size="progressCircleSize"
        :width="2"
        :color="color"
        indeterminate
      > </v-progress-circular>
      <span v-if="loading && showTextProgress">
        Fetching location
      </span>
      <slot>
      {{ label }}
      </slot>
    </span>
    
    <span class="geolocation-coords" v-if="showCoords">
      <p>Latitude: {{ geolocation?.latitude }}</p>
      <p>Longitude: {{ geolocation?.longitude }}</p>
    </span>
    
  </span>
  

</template>


<script lang="ts">
import { defineComponent } from 'vue';
import { VBtn } from 'vuetify/components/VBtn';
import { VProgressCircular } from 'vuetify/lib/components/index.mjs';

type Density = null | 'default' | 'comfortable' | 'compact';

export default defineComponent({
  
  name: 'GeolocationButton',


  components: {
    'v-btn': VBtn,
    'v-progress-circular': VProgressCircular,
  },

  props: {
    color: {
      type: String,
      default: 'white',
    },
    debug: {
      type: Boolean,
      default: false,
    },


    disabled: {
      type: Boolean,
      default: false,
    },

    size: {
      type: String,
      default: 'small',
    },

    density: {
      type: String as () => Density,
      default: 'comfortable',
    },


    elevation: {
      type: String,
      default: "2",
    },

    hideButton: {
      type: Boolean,
      default: false,
    },

    showTextLabel: {
      type: Boolean,
      default: false,
    },

    showCoords: {
      type: Boolean,
      default: false,
    },

    showTextProgress: {
      type: Boolean,
      default: false,
    },

    useTextButton: {
      type: Boolean,
      default: false,
    },

    progressCircleSize: {
      type: Number,
      default: 12,
    },
      

    label: {
      type: String,
      default: 'My Location',
    },

    id: {
      type: String,
      default: null,
    },

    trueIcon: {
      type: String,
      default: 'mdi-crosshairs-gps',
    },

    falseIcon: {
      type: String,
      default: 'mdi-crosshairs',
    },
    
    backgroundColor: {
      type: String,
      default: 'black',
    },
    
    
  },

  emits: {
    // declare emits but w/o any verification. -_- 
    geolocation: (_payload: GeolocationCoordinates) => true,
    error: (_payload: GeolocationPositionError) => true,
    permission: (_payload: boolean | string) => true,
    permissionDenied: (_payload: boolean) => true,
  },
  
  data() {
    return {
      geolocation: null as GeolocationCoordinates | null,
      geolocationError: null as GeolocationPositionError | null,
      hasPermission: false,
      loading: false,
      show: false,
    };
  },
  
  created() {
  },
  
  mounted() {
    
    // Check the Permissions API to see if the user has
    // granted the browser permission to access their location
    const query = navigator.permissions.query({ name: 'geolocation' });
    query.then((result) => {
      this.handlePermission(result);
      result.addEventListener('change', () => {
        this.handlePermission(result);
      });
    });
    
    
  },

  computed: {
    icon() {
      return this.geolocation ? this.trueIcon : this.falseIcon;
    },
  },

  methods: {
    
    handlePermission(result: PermissionStatus) { 
      
      if (result.state === 'granted') {
        this.show = true;
      } else if (result.state === 'prompt') {
        this.show = true;
      } else if (result.state === 'denied') {
        this.show = false;
        this.$emit('permissionDenied', true);
      }
      console.log('Permission:', result.state);
      this.$emit('permission', result.state);
    },
    
    
    handlePosition(position: GeolocationPosition) {
      // Handle the position
      this.geolocation = position.coords;
      this.geolocationError = null;
      this.$emit('geolocation', this.geolocation);
    },
    
    handleGeolocationError(error: GeolocationPositionError) {
      // Handle the error
      this.geolocationError = error;
      console.error('Geolocation error:', error);
      this.$emit('error', this.geolocationError);
    },
    
    geolocate() {
      
      if (this.geolocation) {
        this.$emit('geolocation', this.geolocation);
        return;
      }
      
      const options = {
        enableHighAccuracy: true,
        timeout: 60 * 1000, // 1 minute
        maximumAge: 0,
      };
      
      
      if (navigator.geolocation) {
        this.loading = true;  
        navigator.geolocation.getCurrentPosition(
          (position) => {
            this.handlePosition(position);
            this.loading = false;
          },
          
          (error) => {
            this.handleGeolocationError(error);
            this.loading = false;
          },
          options
        );
      } 
        
    },
    
    getLocation() {
      // Get the users location, and emit and event with
      // the coordinates or the error
      console.log(this.showTextProgress, this.showTextLabel, this.useTextButton, this.showCoords, this.hideButton);
      
      this.geolocate();
      
    },
  },

  watch: {
    
    geolocation(val: GeolocationCoordinates) {
      this.$emit('geolocation', val);
    },
    
  }
  
});

</script>
